var __awaiter =
  (this && this.__awaiter) ||
  function (thisArg, _arguments, P, generator) {
    function adopt(value) {
      return value instanceof P
        ? value
        : new P(function (resolve) {
            resolve(value);
          });
    }
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }
      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }
      function step(result) {
        result.done
          ? resolve(result.value)
          : adopt(result.value).then(fulfilled, rejected);
      }
      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  };
import { OpenApiBuilder } from "openapi3-ts";
import { uniq } from "lodash";
import convert from "./samples-to-json-schema";
/**
 * Extracts path names e.g. /api/{extractsThis}/example
 *  = ["extractsThis"]
 */
const extractPathNames = (str) => {
  const regex = /({.+?})/gm;
  let m;
  const out = [];
  while ((m = regex.exec(str)) !== null) {
    if (m.index === regex.lastIndex) {
      regex.lastIndex++;
    }
    m.forEach((match) => {
      out.push(match);
    });
  }
  return out;
};
const DEFAULTS = {
  title: "OpenAPI",
  description: "Generated by at-your-service",
  version: "1.0.0",
};
const openAPIValidMethods = new Set([
  "get",
  "post",
  "put",
  "delete",
  "options",
  "patch",
  "head",
  "trace",
]);
/**
 * Takes a StoreStructure and converts it to an OpenAPIObject
 * Returns an interface to get the OpenAPIObject, JSON, or YAML
 */
const storeStructToOpenApi = (store) =>
  __awaiter(void 0, void 0, void 0, function* () {
    const spec = OpenApiBuilder.create();
    // The library assumes 3.0.0, but the generated spec is 3.1.0
    spec.rootDoc.openapi = "3.1.0";
    spec.addTitle(DEFAULTS.title);
    spec.addDescription(DEFAULTS.description);
    spec.addVersion(DEFAULTS.version);
    for (const host in store) {
      for (const pathname in store[host]) {
        for (const method in store[host][pathname]) {
          if (!openAPIValidMethods.has(method.toLowerCase())) {
            continue;
          }
          for (let status in store[host][pathname][method]) {
            // Remove the prefix character from the status code
            const { reqSamples, resSamples } =
              store[host][pathname][method][status];
            status = status.slice(1);
            /**
             * RESPONSE OBJECT CREATION
             */
            const resMediaType = {
              schema: convert(resSamples),
            };
            const resContent = {
              "application/json": resMediaType,
            };
            // A concrete response definition
            const response = {
              content: resContent,
              description: `Response for ${pathname} ${method} ${status}`,
            };
            // All the different responses we can get from 200, 400, 204, etc
            const responses = {
              [status]: response,
            };
            /**
             * REQUEST OBJECT CREATION
             */
            const reqMediaType = {
              schema: convert(reqSamples),
            };
            const reqContent = {
              "application/json": reqMediaType,
            };
            const requestBody = {
              content: reqContent,
              description: `Request for ${pathname} ${method} ${status}`,
            };
            /**
             * WRAP UP INTO OPERATION, PATH ITEM, AND PUT INTO PATH
             */
            // Some methods have no req body https://swagger.io/docs/specification/describing-request-body/
            const hasRequestBody = !new Set(["get", "delete", "head"]).has(
              method.toLowerCase()
            );
            const pathNames = uniq(extractPathNames(pathname));
            const parameters = pathNames.map((name) => ({
              name,
              in: "path",
              required: true,
              schema: {
                type: "string",
              },
            }));
            // The req/res associated with a HTTP [VERB] request
            const operation = {
              summary: `Summary for ${pathname} ${method} ${status}`,
              description: `${method} call to ${pathname} with status ${status}`,
              responses,
            };
            if (parameters.length) {
              operation.parameters = parameters;
            }
            if (hasRequestBody) {
              operation.requestBody = requestBody;
            }
            // The method (e.g. get) and the operation on it
            const pathItem = {
              [method.toLowerCase()]: operation,
            };
            // Add the resulting object to the spec
            spec.addPath(pathname, pathItem);
          }
        }
      }
    }
    return {
      getSpec: () => spec.getSpec(),
      getJSON: () => spec.getSpecAsJson(),
      getYAML: () => spec.getSpecAsYaml(),
    };
  });
export default storeStructToOpenApi;
