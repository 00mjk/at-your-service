import type { StoreStructure } from "../../types";
import {
  OpenAPIObject,
  OpenApiBuilder,
  PathItemObject,
  OperationObject,
  ResponseObject,
  ContentObject,
  ResponsesObject,
  MediaTypeObject,
  RequestBodyObject,
  ParameterObject,
} from "openapi3-ts";
import { ReadonlyDeep } from "type-fest";

import convert from "./json-to-json-schema";

const extractPathNames = (str: string) => {
  const regex = /({.+?})/gm;

  // Alternative syntax using RegExp constructor
  // const regex = new RegExp('({.+?})', 'gm')

  let m;

  const out = [];
  while ((m = regex.exec(str)) !== null) {
    // This is necessary to avoid infinite loops with zero-width matches
    if (m.index === regex.lastIndex) {
      regex.lastIndex++;
    }

    // The result can be accessed through the `m`-variable.
    m.forEach((match, groupIndex) => {
      // @ts-ignore
      out.push(match);
    });
  }
  return out;
};

type StoreStructToOpenApi = (store: StoreStructure) => Promise<
  ReadonlyDeep<{
    getSpec: () => OpenAPIObject;
    getJSON: () => string;
    getYAML: () => string;
  }>
>;

type Defaults = {
  title: string;
  description: string;
  version: string;
};

const DEFAULTS: ReadonlyDeep<Defaults> = {
  title: "OpenAPI",
  description: "Generated by at-your-service",
  version: "1.0.0",
};

const openAPIValidMethods = new Set([
  "get",
  "post",
  "put",
  "delete",
  "options",
  "patch",
  "head",
  "trace",
]);

/**
 * Based on the OpenAPI 3.1 spec
 *
 * - OpenAPIObject
 *  - PathObject
 */

/**
 * Takes a StoreStructure and converts it to an OpenAPIObject
 * Returns an interface to get the OpenAPIObject, JSON, or YAML
 */
const storeStructToOpenApi: StoreStructToOpenApi = async (store) => {
  const spec: OpenApiBuilder = OpenApiBuilder.create();

  spec.addTitle(DEFAULTS.title);
  spec.addDescription(DEFAULTS.description);
  spec.addVersion(DEFAULTS.version);

  for (const host in store) {
    for (const pathname in store[host]) {
      for (const method in store[host][pathname]) {
        if (!openAPIValidMethods.has(method.toLowerCase())) {
          continue;
        }
        for (let status in store[host][pathname][method]) {
          // Remove the prefix character from the status code
          const { reqSamples, resSamples } =
            store[host][pathname][method][status];
          status = status.slice(1);

          /**
           * RESPONSE OBJECT CREATION
           */
          const resMediaType: MediaTypeObject = {
            schema: convert(resSamples),
          };
          const resContent: ContentObject = {
            "application/json": resMediaType,
          };
          // A concrete response definition
          const response: ResponseObject = {
            content: resContent,
            description: `Response for ${pathname} ${method} ${status}`,
          };
          // All the different responses we can get from 200, 400, 204, etc
          const responses: ResponsesObject = {
            [status]: response,
          };
          /**
           * REQUEST OBJECT CREATION
           */
          const reqMediaType: MediaTypeObject = {
            schema: convert(reqSamples),
          };
          const reqContent: ContentObject = {
            "application/json": reqMediaType,
          };

          const requestBody: RequestBodyObject = {
            content: reqContent,
            description: `Request for ${pathname} ${method} ${status}`,
          };
          /**
           * WRAP UP INTO OPERATION, PATH ITEM, AND PUT INTO PATH
           */
          // Some methods have no req body https://swagger.io/docs/specification/describing-request-body/
          const hasRequestBody = !new Set(["get", "delete", "head"]).has(
            method.toLowerCase()
          );
          const pathNames = extractPathNames(pathname);
          const parameters: ParameterObject[] = pathNames.map((name) => ({
            name,
            in: "path",
            required: true,
          }));
          // The req/res associated with a HTTP [VERB] request
          const operation: OperationObject = {
            summary: `Summary for ${pathname} ${method} ${status}`,
            description: `${method} call to ${pathname} with status ${status}`,
            responses,
          };
          if (parameters.length) {
            operation.parameters = parameters;
          }
          if (hasRequestBody) {
            operation.requestBody = requestBody;
          }
          // The method (e.g. get) and the operation on it
          const pathItem: PathItemObject = {
            [method.toLowerCase()]: operation,
          };
          // Add the resulting object to the spec
          spec.addPath(pathname, pathItem);
        }
      }
    }
  }

  return {
    getSpec: () => spec.getSpec(),
    getJSON: () => spec.getSpecAsJson(),
    getYAML: () => spec.getSpecAsYaml(),
  };
};

export default storeStructToOpenApi;
